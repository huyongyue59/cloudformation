#!/bin/bash
# interactive logger - 固定原始登录用户并把每条命令以 NDJSON 追加到 user-specific 文件

# 固定原始登录用户（只在第一次赋值）
export ORIG_LOGIN_USER="${ORIG_LOGIN_USER:-$(id -un)}"

LOG_DIR="/data/logs"
LOG_FILE="$LOG_DIR/${ORIG_LOGIN_USER}_commands.json"

# 保证日志目录存在（存在则不报错）
mkdir -p "$LOG_DIR"
chmod 775 "$LOG_DIR" 2>/dev/null || true

# 如果文件不存在，尝试由当前进程创建（属主将是创建时的实际用户）
if [ ! -f "$LOG_FILE" ]; then
    touch "$LOG_FILE" 2>/dev/null || true
    chmod 664 "$LOG_FILE" 2>/dev/null || true
fi

while true; do
    read -e -p "$ " CMD
    [[ -z "$CMD" ]] && continue
    [[ "$CMD" == "exit" ]] && break

    TIMESTAMP=$(date '+%Y-%m-%dT%H:%M:%S%z')

    # 执行命令并捕获输出
    OUTPUT=$(eval "$CMD" 2>&1)

    # JSON-safe 转义：先转义反斜杠，再转义双引号，再把换行换成 \n
    ESCAPED_CMD=$(printf '%s' "$CMD" | sed ':a;N;$!ba;s/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g')
    ESCAPED_OUTPUT=$(printf '%s' "$OUTPUT" | sed ':a;N;$!ba;s/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g')

    JSON_LINE="{\"timestamp\":\"$TIMESTAMP\",\"user\":\"$ORIG_LOGIN_USER\",\"cmd\":\"$ESCAPED_CMD\",\"output\":\"$ESCAPED_OUTPUT\"}"

    # 原子追加，防止多个会话写冲突
    (
        flock -x 200
        printf '%s\n' "$JSON_LINE" >&200
    ) 200>>"$LOG_FILE"

    # 把命令输出回显到终端
    printf '%s\n' "$OUTPUT"
done
